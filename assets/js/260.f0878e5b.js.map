{"version":3,"sources":["webpack:///./docs/cache-pdp/057.md","webpack:///./docs/cache-pdp/057.md?d303","webpack:///./docs/cache-pdp/057.md?9a2b"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAiF;AACjF;;;AAGA;AAC0F;AAC1F,gBAAgB,2GAAU;AAC1B;AACA,EAAE,6EAAM;AACR,EAAE,sFAAe;AACjB;AACA;AACA;AACA;;AAEA;;AAEe,gF;;;;;;;;;;;;ACjBf;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA,0BAA0B,aAAa,0BAA0B,wBAAwB,qCAAqC,OAAO,gCAAgC,WAAW,OAAO,gDAAgD,UAAU,mCAAmC,mDAAmD;AACvU","file":"assets/js/260.f0878e5b.js","sourcesContent":["import { render, staticRenderFns } from \"./057.md?vue&type=template&id=774a74bb&\"\nvar script = {}\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../node_modules/cache-loader/dist/cjs.js?{\\\"cacheDirectory\\\":\\\"node_modules/@vuepress/core/node_modules/.cache/vuepress\\\",\\\"cacheIdentifier\\\":\\\"2e9acca5-vue-loader-template\\\"}!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??ref--1-1!../../node_modules/@vuepress/markdown-loader/index.js??ref--1-2!./057.md?vue&type=template&id=774a74bb&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ContentSlotsDistributor',{attrs:{\"slot-key\":_vm.$parent.slotKey}},[_c('h1',{attrs:{\"id\":\"_057-分布式缓存重建并发冲突问题以及-zookeeper-分布式锁解决方案\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_057-分布式缓存重建并发冲突问题以及-zookeeper-分布式锁解决方案\"}},[_vm._v(\"#\")]),_vm._v(\" 057. 分布式缓存重建并发冲突问题以及 zookeeper 分布式锁解决方案\")]),_vm._v(\" \"),_c('p',[_vm._v(\"整个三级缓存的架构已经走通了，对于 3 级缓存失效，缓存重建并发冲突问题还没有解决。\")]),_vm._v(\" \"),_c('p',[_vm._v(\"什么是分布式缓存重建并发冲突问题？\")]),_vm._v(\" \"),_c('p',[_vm._v(\"很简单，多个缓存服务实例提供服务，发现缓存失效，那么就会去重建，这个时候回出现以下几种情况：\")]),_vm._v(\" \"),_c('ol',[_c('li',[_c('p',[_vm._v(\"多个缓存实例都去数据库获取一份数据，然后放入缓存中\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"新数据被旧数据覆盖\")]),_vm._v(\" \"),_c('p',[_vm._v(\"缓存 a 和 b 都拿了一份数据，a 拿到 12:00:01 的数据，b 拿到 12:00:05 的数据\")]),_vm._v(\" \"),_c('p',[_vm._v(\"缓存 b 先写入 redis，缓存 a 后写入。\")])])]),_vm._v(\" \"),_c('p',[_vm._v(\"以上问题有多重解决方案，如：\")]),_vm._v(\" \"),_c('ol',[_c('li',[_c('p',[_vm._v(\"利用 hash 分发\")]),_vm._v(\" \"),_c('p',[_vm._v(\"相同商品分发到同一个服务中，服务中再用队列去重建\")]),_vm._v(\" \"),_c('p',[_vm._v(\"但是这就变成了有状态的缓存服务，压力全部集中到同一个服务上\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"利用 kafka 队列\")]),_vm._v(\" \"),_c('p',[_vm._v(\"源头信息服务，在发送消息到 kafka topic 的时候，都需要按照 product id 去分区\")]),_vm._v(\" \"),_c('p',[_vm._v(\"和上面 hash 方案类似\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"基于 zookeeper 分布式锁的解决方案\")])])]),_vm._v(\" \"),_c('p',[_vm._v(\"分布式锁：多个机器在访问同一个共享资源，需要给这个资源加一把锁，让多个机器串行访问\")]),_vm._v(\" \"),_c('p',[_vm._v(\"对于分布式锁，有很多种实现方式，比如 redis 也可以实现。\")]),_vm._v(\" \"),_c('p',[_vm._v(\"这里讲解 zk 分布式锁，zk 做分布式协调比较流程，大数据应用里面 hadoop、storm 都是基于 zk 去做分布式协调\")]),_vm._v(\" \"),_c('p',[_vm._v(\"zk 分布式锁的解决并发冲突的方案\")]),_vm._v(\" \"),_c('ol',[_c('li',[_vm._v(\"变更缓存重建以及空缓存请求重建，更新 redis 之前，都需要先获取对应商品 id 的分布式锁\")]),_vm._v(\" \"),_c('li',[_vm._v(\"拿到分布式锁之后，需要根据时间版本去比较一下，如果自己的版本新于 redis 中的版本，那么就更新，否则就不更新\")]),_vm._v(\" \"),_c('li',[_vm._v(\"如果拿不到分布式锁，那么就等待，不断轮询等待，直到自己获取到分布式的锁\")])])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"],"sourceRoot":""}