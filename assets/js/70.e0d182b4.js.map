{"version":3,"sources":["webpack:///./docs/cache-pdp/redis/027.md","webpack:///./docs/cache-pdp/redis/027.md?6794","webpack:///./docs/cache-pdp/redis/assets/markdown-img-paste-20190324173026866.png","webpack:///./docs/cache-pdp/redis/assets/markdown-img-paste-20190324173702728.png","webpack:///./docs/cache-pdp/redis/assets/markdown-img-paste-20190324174432368.png","webpack:///./docs/cache-pdp/redis/assets/markdown-img-paste-20190324175507252.png","webpack:///./docs/cache-pdp/redis/027.md?f245"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAiF;AACjF;;;AAGA;AAC6F;AAC7F,gBAAgB,2GAAU;AAC1B;AACA,EAAE,6EAAM;AACR,EAAE,sFAAe;AACjB;AACA;AACA;AACA;;AAEA;;AAEe,gF;;;;;;;;;;;;ACjBf;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;ACAA,iBAAiB,qBAAuB,kE;;;;;;;;;;;ACAxC,iBAAiB,qBAAuB,kE;;;;;;;;;;;ACAxC,iBAAiB,qBAAuB,kE;;;;;;;;;;;ACAxC,iBAAiB,qBAAuB,kE;;;;;;;;;;;;ACAxC;AAAA;AAAA;AAAA,0BAA0B,aAAa,0BAA0B,wBAAwB,qCAAqC,OAAO,gCAAgC,WAAW,OAAO,4DAA4D,UAAU,mCAAmC,+DAA+D,kHAAkH,gCAAgC,4BAA4B,OAAO,4BAA4B,kDAAkD,OAAO,kCAAkC,yDAAyD,OAAO,0CAA0C,mEAAmE,OAAO,wCAAwC,iYAAiY,OAAO,yBAAyB,UAAU,mCAAmC,4BAA4B,qgBAAqgB,OAAO,+BAA+B,UAAU,mCAAmC,kCAAkC,mFAAmF,OAAO,MAAM,mBAAO,CAAC,iIAAmD,YAAY,8FAA8F,OAAO,uCAAuC,UAAU,mCAAmC,0CAA0C,6FAA6F,OAAO,MAAM,mBAAO,CAAC,iIAAmD,YAAY,4TAA4T,OAAO,MAAM,mBAAO,CAAC,iIAAmD,YAAY,0SAA0S,OAAO,qCAAqC,UAAU,mCAAmC,wCAAwC,orBAAorB,OAAO,MAAM,mBAAO,CAAC,iIAAmD,YAAY;AACzkI","file":"assets/js/70.e0d182b4.js","sourcesContent":["import { render, staticRenderFns } from \"./027.md?vue&type=template&id=6c5dde47&\"\nvar script = {}\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../../node_modules/cache-loader/dist/cjs.js?{\\\"cacheDirectory\\\":\\\"node_modules/@vuepress/core/node_modules/.cache/vuepress\\\",\\\"cacheIdentifier\\\":\\\"2e9acca5-vue-loader-template\\\"}!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??ref--1-1!../../../node_modules/@vuepress/markdown-loader/index.js??ref--1-2!./027.md?vue&type=template&id=6c5dde47&\"","module.exports = __webpack_public_path__ + \"assets/img/markdown-img-paste-20190324173026866.ec94086f.png\";","module.exports = __webpack_public_path__ + \"assets/img/markdown-img-paste-20190324173702728.439aad6c.png\";","module.exports = __webpack_public_path__ + \"assets/img/markdown-img-paste-20190324174432368.0be57433.png\";","module.exports = __webpack_public_path__ + \"assets/img/markdown-img-paste-20190324175507252.d37f9a37.png\";","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ContentSlotsDistributor',{attrs:{\"slot-key\":_vm.$parent.slotKey}},[_c('h1',{attrs:{\"id\":\"_027-数据分布算法-hash-一致性-hash-redis-cluster-的-hash-slot\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_027-数据分布算法-hash-一致性-hash-redis-cluster-的-hash-slot\"}},[_vm._v(\"#\")]),_vm._v(\" 027. 数据分布算法：hash+ 一致性 hash + redis cluster 的 hash slot\")]),_vm._v(\" \"),_c('p'),_c('div',{staticClass:\"table-of-contents\"},[_c('ul',[_c('li',[_c('a',{attrs:{\"href\":\"#redis-cluster-介绍\"}},[_vm._v(\"redis cluster 介绍\")])]),_c('li',[_c('a',{attrs:{\"href\":\"#最老土的-hash-算法和弊端-大量缓存重建\"}},[_vm._v(\"最老土的 hash 算法和弊端（大量缓存重建）\")])]),_c('li',[_c('a',{attrs:{\"href\":\"#一致性-hash-算法-自动缓存迁移-虚拟节点-自动负载均衡\"}},[_vm._v(\"一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）\")])]),_c('li',[_c('a',{attrs:{\"href\":\"#redis-cluster-的-hash-slot-算法\"}},[_vm._v(\"redis cluster 的 hash slot 算法\")])])])]),_c('p'),_vm._v(\" \"),_c('p',[_vm._v(\"讲解分布式数据存储的核心算法，数据分布的算法\")]),_vm._v(\" \"),_c('p',[_vm._v(\"hash 算法 -> 一致性 hash 算法（memcached） -> redis cluster 的 hash slot 算法\")]),_vm._v(\" \"),_c('p',[_vm._v(\"用不同的算法，就决定了在多个 master 节点的时候，数据如何分布到这些节点上去，解决这个问题\")]),_vm._v(\" \"),_c('p',[_vm._v(\"看到这里的时候，已经明白了，可能是通过 key 去路由到多个 master 上的\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"redis-cluster-介绍\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#redis-cluster-介绍\"}},[_vm._v(\"#\")]),_vm._v(\" redis cluster 介绍\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"自动将数据进行分片，每个 master 上放一部分数据\")]),_vm._v(\" \"),_c('li',[_vm._v(\"提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是加 10000 的端口号，比如 16379\")]),_vm._v(\" \"),_c('p',[_vm._v(\"16379 端口号是用来进行节点间通信的，通过 cluster bus（集群总线）。cluster bus 的通信是用来进行故障检测，配置更新，故障转移授权\")]),_vm._v(\" \"),_c('p',[_vm._v(\"cluster bus 用了另外一种二进制的协议，主要用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"最老土的-hash-算法和弊端-大量缓存重建\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#最老土的-hash-算法和弊端-大量缓存重建\"}},[_vm._v(\"#\")]),_vm._v(\" 最老土的 hash 算法和弊端（大量缓存重建）\")]),_vm._v(\" \"),_c('p',[_c('img',{attrs:{\"src\":require(\"./assets/markdown-img-paste-20190324173026866.png\"),\"alt\":\"\"}})]),_vm._v(\" \"),_c('p',[_vm._v(\"的确它的最大弊端就是，增加或者减少节点的时候，基本上所有数据都要重建路由\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"一致性-hash-算法-自动缓存迁移-虚拟节点-自动负载均衡\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#一致性-hash-算法-自动缓存迁移-虚拟节点-自动负载均衡\"}},[_vm._v(\"#\")]),_vm._v(\" 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）\")]),_vm._v(\" \"),_c('p',[_c('img',{attrs:{\"src\":require(\"./assets/markdown-img-paste-20190324173702728.png\"),\"alt\":\"\"}})]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"优点：自动缓存迁移\")]),_vm._v(\" \"),_c('li',[_vm._v(\"缺点：缓存热点问题\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"一致性 hash 的严重问题是缓存热点，关键字是 \"),_c('strong',[_vm._v(\"区间\")]),_vm._v(\"，因为它是一个环，顺时针找可用节点，所以只要节点够多，就能更均匀的均衡负载。\")]),_vm._v(\" \"),_c('p',[_vm._v(\"所以出现了虚拟节点，来解决这个缺点\")]),_vm._v(\" \"),_c('p',[_c('img',{attrs:{\"src\":require(\"./assets/markdown-img-paste-20190324174432368.png\"),\"alt\":\"\"}})]),_vm._v(\" \"),_c('p',[_vm._v(\"如上图，假设只有 3 个物理节点，但是在这个环上，分布了若干个虚拟节点（最后指向的是物理节点）\")]),_vm._v(\" \"),_c('p',[_vm._v(\"对于数据落在 1-3 这个区间\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"无虚拟节点：顺时针向右，全部导向了节点 3\")]),_vm._v(\" \"),_c('li',[_vm._v(\"有虚拟节点：顺时针向右，被多个虚拟节点分割，可能会遇上节点 1、2、3 。这样就负载均衡了\")])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"redis-cluster-的-hash-slot-算法\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#redis-cluster-的-hash-slot-算法\"}},[_vm._v(\"#\")]),_vm._v(\" redis cluster 的 hash slot 算法\")]),_vm._v(\" \"),_c('p',[_vm._v(\"redis cluster 有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot\")]),_vm._v(\" \"),_c('p',[_vm._v(\"redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot\")]),_vm._v(\" \"),_c('p',[_vm._v(\"hash slot 让 node 的增加和移除很简单：\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"增加一个 master，就将其他 master 的 hash slot 移动部分过去\")]),_vm._v(\" \"),_c('li',[_vm._v(\"减少一个 master，就将它的 hash slot 移动到其他 master 上去\")])]),_vm._v(\" \"),_c('p',[_vm._v(\"移动 hash slot 的成本是非常低的\")]),_vm._v(\" \"),_c('p',[_vm._v(\"客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 hash tag 来实现\")]),_vm._v(\" \"),_c('p',[_c('img',{attrs:{\"src\":require(\"./assets/markdown-img-paste-20190324175507252.png\"),\"alt\":\"\"}})]),_vm._v(\" \"),_c('p',[_vm._v(\"如上图，思路与一致性 hash 是一样的。通过更过的 hash slot，将路由分布得更均匀。\\n当一台机器挂掉之后，会在极短的时间内，将挂掉的 hash slot 分配给其他两个物理节点\")]),_vm._v(\" \"),_c('p',[_vm._v(\"可以看成是 -> hash slot -> 机器，hash slot 数量固定，不一一对应机器，动态分配的。\")])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"],"sourceRoot":""}